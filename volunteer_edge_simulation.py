# -*- coding: utf-8 -*-
"""Another copy of VEC_KPI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XTuII9a251-GVxA8S1oGB5QJJG4TArVz
"""

class GeneralUnit:
    __slots__ = ['name', 'location', 'capacity', 'costRate', 'connection', 'energy', 'totalEnergyConsumed', 'costParams']

    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)

        # Add cost parameters for computation, bandwidth, and energy
        self.costParams = {
            'CPUCostPerSec': 0.05,  # Cost per second of CPU computation [$/sec]
            'BandwidthCostPerMb': 0.01,  # Cost per MB of data transfer [$/MB]
            'EnergyCostPerWh': 0.02  # Cost per watt-hour [$/Wh]

        }

        # Transmission power, fading, noise, etc.
        self.transmissionPower = 10  # [dBm]
        self.transmissionPower = 10 ** (self.transmissionPower / 10)  # [mW]
        self.fadingCoeff = np.random.uniform(0.5, 0.9)  # Random fading coefficient
        self.pathLossExponent = np.random.uniform(2, 3.5)  # Dynamic path loss (2-4)
        self.noisePower = 0.001  # Reduced noise power for more realistic conditions
        self.totalEnergyConsumed = 0  # Initialize total energy consumed
        self.endTime = datetime.datetime.now()  # The end time of a unit is the time at which it finished its last job
        self.log = {'taskIDs': [], 'taskExecutionTime': [], 'taskArrivalTime': [], 'taskEndTime': []}

    def setNetworkType(self, networkType):
        if networkType == 'WLAN':
            self.connection = {'bandwidth': np.random.uniform(50, 600), 'latency': np.random.uniform(0.001, 0.01)}
        elif networkType == 'WAN':
            self.connection = {'bandwidth': np.random.uniform(10, 100), 'latency': np.random.uniform(0.05, 0.1)}
        elif networkType == 'Wi-Fi':
            self.connection = {'bandwidth': np.random.uniform(50, 867), 'latency': np.random.uniform(0.01, 0.05)}
        elif networkType == 'LTE':
            self.connection = {'bandwidth': np.random.uniform(50, 300), 'latency': np.random.uniform(0.05, 0.1)}
        elif networkType == '5G':
            self.connection = {'bandwidth': np.random.uniform(100, 1000), 'latency': np.random.uniform(0.001, 0.01)}
        else:
            raise ValueError(f"Unknown network type: {networkType}")

    def computeExecutionTime(self, _task, considerEnergy=True):
        # Compute execution time
        computationTime = _task.CPUcycles / self.capacity['CPUspeed']
        dataTransferTime = 0

        if self.getType() != "myDevice":
            dynamicBandwidth = self.connection['bandwidth']
            dynamicLatency = self.connection['latency']
            dataTransferTime = _task.memorySize / dynamicBandwidth + dynamicLatency

        # Compute energy costs if applicable
        totalEnergy = 0
        if considerEnergy:
            computationEnergy = computationTime * self.energy['CPUEnergy'] / 3600  # Energy in Wh
            dataTransferEnergy = 0
            if self.getType() != "myDevice":
                dataTransferEnergy = _task.memorySize * self.energy['bandwidthEnergy'] * dataTransferTime / 3600

            totalEnergy = dataTransferEnergy + computationEnergy
            self.totalEnergyConsumed += totalEnergy

        wirelessTransferTime = self.getWirelessTransferTime(_task.memorySize)

        # Calculate individual costs
        computationCost = computationTime * self.costParams['CPUCostPerSec']
        bandwidthCost = _task.memorySize * self.costParams['BandwidthCostPerMb']
        energyCost = totalEnergy * self.costParams['EnergyCostPerWh']

        # Total execution cost
        totalCost = computationCost + bandwidthCost + energyCost

        return {
            'executionTime': datetime.timedelta(seconds=computationTime + dataTransferTime + wirelessTransferTime),
            'totalCost': totalCost,
            'energyConsumed': totalEnergy
        }

    def getWirelessTransferTime(self, _taskMemorySize):
        wirelessTransferTime = 0
        if self.location > 0.0:
            pathLoss = self.location ** self.pathLossExponent
            pathLoss = max(pathLoss, 1e-10)  # Avoid division by zero
            noisePower = max(self.noisePower, 1e-10)

            channelGain = self.transmissionPower * self.fadingCoeff / (noisePower * pathLoss)
            transmissionRate = self.connection['bandwidth'] * np.log2(1 + channelGain)

            transmissionRate = max(transmissionRate, 1e-10)  # Avoid zero transmission rate
            wirelessTransferTime = (_taskMemorySize / transmissionRate) + self.connection['latency']

        return wirelessTransferTime

    def assignTask(self, _task):
        # Compute execution time and cost
        result = self.computeExecutionTime(_task)
        execTime = result['executionTime']
        totalCost = result['totalCost']

        if execTime.total_seconds() <= 0:
            raise ValueError("Execution time should be positive.")

        if self.endTime < _task.arrivalTime:
            self.endTime = _task.arrivalTime + execTime
        else:
            self.endTime = self.endTime + execTime

        taskStartTime = self.endTime - execTime
        _task.assign(taskStartTime, self.endTime, self.name)

        if _task.endTime <= _task.startTime:
            raise TypeError("Execution time calculation error.")

        # Log the cost and energy usage
        self.append2log(_task.id, _task.getExecutionTime(), _task.arrivalTime, _task.endTime)

        #print(f"Task {_task.id} assigned with total cost: ${totalCost:.2f}")

    def append2log(self, _taskID, _taskExecutionTime, _taskArrivalTime, _taskEndTime):
        self.log['taskIDs'].append(_taskID)
        self.log['taskExecutionTime'].append(_taskExecutionTime)
        self.log['taskArrivalTime'].append(_taskArrivalTime)
        self.log['taskEndTime'].append(_taskEndTime)

    def printLog(self):
        print(f"Log of unit: {self.name}")
        print(f"Unit type: {self.getType()}")
        print(f"Assigned tasks: {self.log['taskIDs']}")

    def getType(self):
        return 'General unit'

    def __str__(self):
        return self.log

import numpy as np
import datetime
import copy
import plotly.express as px
import pandas as pd
from matplotlib import pyplot as plt
import datetime
import random

# Global variables
volunteerTrustTreshold = 0.3
simulationLength = 3600 * 6 #[seconds]
volunteerTimeoutTreshold = datetime.timedelta(seconds=simulationLength * .1)
transitionCoefficient = 1 # Coefficient for transforming energy cost into time cost

"""### Cloud"""

class Cloud(GeneralUnit):
  def __init__(self, **kwargs):
    super().__init__(**kwargs)

  def getType(self):
    return 'cloud'

"""### Edge"""

class Edge(GeneralUnit):
  def __init__(self, **kwargs):
    super().__init__(**kwargs)

  def getType(self):
    return 'edge'

class Volunteer(GeneralUnit):
    def __init__(self, _trust, _availability, **kwargs):
        super().__init__(**kwargs)
        self.trust = _trust
        self.availability = _availability
        self.NexecutedTasks = 0
        self.lastShutdownTime = datetime.datetime.now()
        self.successfulTasks = 0  # Initialize successful tasks
        self.failedTasks = 0  # Initialize failed tasks
        self.totalLatency = 0  # Initialize total latency
        self.totalCompletionTime = 0  # Initialize total completion time

    def getTrust(self):
        return self.trust

    def getType(self):
        return 'volunteer'

    def shutDown(self, _shutDownTime = datetime.datetime.now()):
        self.availability = 0
        self.lastShutdownTime = _shutDownTime
        notExecutedTasksID = []
        for taskI in range(len(self.log['taskIDs'])):
            if(self.log['taskEndTime'][taskI] >= _shutDownTime):
                notExecutedTasksID = self.log['taskIDs'][taskI:]
                del self.log['taskIDs'][taskI:]
                del self.log['taskExecutionTime'][taskI:]
                del self.log['taskArrivalTime'][taskI:]
                del self.log['taskEndTime'][taskI:]
                break
        NcurrentExecutedTasks = len(self.log['taskIDs']) - self.NexecutedTasks
        NnotExecutedTasks = len(notExecutedTasksID)
        self.NexecutedTasks = len(self.log['taskIDs'])

        self.trust = self.trust * (NcurrentExecutedTasks + 2) / \
          (NnotExecutedTasks + NcurrentExecutedTasks + 2)
        return notExecutedTasksID

    def turnOn(self):
        self.availability = 1

    def restoreTrust(self):
        self.trust = 0.5

    def updateTrust(self, task, network_units):
        if task.successFlag:
            self.successfulTasks += 1
            self.totalLatency += task.getQueingTime(network_units).total_seconds()  # Correct handling of timedelta
            self.totalCompletionTime += task.getExecutionTime().total_seconds()
        else:
            self.failedTasks += 1

        # Calculate advanced trust score
        success_rate = self.successfulTasks / (self.successfulTasks + self.failedTasks + 1)
        avg_latency = self.totalLatency / (self.successfulTasks + 1)
        avg_completion_time = self.totalCompletionTime / (self.successfulTasks + 1)
        self.trust = 0.5 * success_rate + 0.25 * (1 / (1 + avg_latency)) + 0.25 * (1 / (1 + avg_completion_time))


    def getUntrustedTime(self, _time):
        return _time - self.lastShutdownTime

"""### Local device"""

class LocalDevice(GeneralUnit):
  def __init__(self, **kwargs):
    kwargs['name'] = "myDevice"
    kwargs['location'] = 0
    kwargs['costRate'] = 0
    super().__init__(**kwargs)

  def getType(self):
    return 'localDevice'

"""## Tasks class"""

class Task:
  __slots__ = ['id', 'type', 'priority', 'arrivalTime', 'deadlineTime',
               'delayTolerance', 'CPUcycles', 'memorySize', 'incentive',
               'startTime', 'endTime', 'wastedTime',
               'assignedUnit', 'successFlag', 'assignmentCounter']

  def __init__(self, **kwargs):
    for key, value in kwargs.items():
      setattr(self, key, value)
    self.wastedTime = datetime.timedelta(seconds=0.0)
    self.successFlag = True
    self.assignmentCounter = 0

  def setArrivalTime(self, _arrival):
    self.arrivalTime = _arrival

  def setStartTime(self, _start):
    self.startTime = _start

  def setEndTime(self, _end):
    self.endTime = _end

  def setUnitName(self, _name):
    self.assignedUnit = _name

  def assign(self, _startTime, _endTime, _unitName):
    self.assignmentCounter = self.assignmentCounter + 1
    self.setStartTime(_startTime)
    self.setEndTime(_endTime)
    self.setUnitName(_unitName)

  def notAssigned(self):
    self.successFlag = False
    self.endTime = datetime.datetime(1, 1, 1, 0, 0)
    self.assignedUnit = "None"

  def prepareForReassignment(self, _reassignmentTime):
    self.wastedTime = self.wastedTime + _reassignmentTime - self.arrivalTime
    self.arrivalTime = _reassignmentTime
    self.assignedUnit = "None"
    self.startTime = None
    self.endTime = None

  def getExecutionTime(self):
    if self.assignedUnit == "None":
      raise TypeError("Cannot call this funcion because this task was not assigned")
    return self.endTime - self.startTime

  #def getQueingTime(self):
   # if self.assignedUnit == "None":
    #  raise TypeError("Cannot call this funcion because this task was not assigned")
    #return self.startTime - self.arrivalTime + self.wastedTime

  def getQueingTime(self, network_units):
      if self.assignedUnit == "None":
          raise TypeError("Cannot call this function because this task was not assigned")

      # Access the actual unit object using the assigned unit name
      unit = network_units[self.assignedUnit]

      # Calculate data transfer time based on task memory size, bandwidth, distance, and latency
      dataTransferTime = 0
      if unit.getType() != "myDevice":
          # Use distance to calculate the path loss
          pathLoss = unit.pathLossExponent * unit.location  # Use location (distance)

          # Avoid division by zero by ensuring noise power and path loss are non-zero
          if pathLoss == 0 or unit.noisePower == 0:
              pathLoss = 1e-9  # Small value to prevent division by zero

          channelGain = unit.transmissionPower * unit.fadingCoeff / (unit.noisePower * pathLoss)

          # Ensure bandwidth is not zero
          if unit.connection['bandwidth'] == 0:
              transmissionRate = 1e-9  # Small value to avoid division by zero
          else:
              transmissionRate = unit.connection['bandwidth'] * np.log2(1 + channelGain)

          # Data transfer time including the transmission rate and latency
          dataTransferTime = self.memorySize / transmissionRate + unit.connection['latency']

      # Return as a timedelta object for consistency with other time-based calculations
      return datetime.timedelta(seconds=dataTransferTime)







  def print(self):
    print('\nTask ID = ', self.id)
    print('Arrival time = ', self.arrivalTime - self.wastedTime )
    print('Start time = ', self.startTime)
    print('Queing time = ', self.getQueingTime(), 's')
    print('Execution time = ', self.getExecutionTime(), 's')
    print('End time = ', self.endTime)
    print('Assigned unit = ', self.assignedUnit)
    print('Success = ', self.successFlag)

import numpy as np
import datetime

def randomTaskGenerator(_Ntasks, simulationLength):
    tasks = []
    current_time = datetime.datetime.now()

    for taskI in range(_Ntasks):
        # Assign task type based on the usage percentages from the table
        task_type = np.random.choice(['AR', 'HM', 'I'], p=[0.5, 0.3, 0.2])

        # Set parameters based on the task type
        if task_type == 'AR':  # Augmented Reality
            interarrival_time = np.random.exponential(2)  # Mean of 2 seconds for AR
            CPUcycles = 20000  # 20 Giga Instructions
            memorySize = 1500  # Upload data size in kB
            deadlineTime = np.random.uniform(300, 900)  # Deadline in seconds
        elif task_type == 'HM':  # Health Monitoring
            interarrival_time = np.random.exponential(5)  # Mean of 5 seconds for HM
            CPUcycles = 7500  # 7.5 Giga Instructions
            memorySize = 25  # Upload data size in kB
            deadlineTime = np.random.uniform(180, 600)  # Deadline in seconds
        elif task_type == 'I':  # Infotainment
            interarrival_time = np.random.exponential(10)  # Mean of 10 seconds for Infotainment
            CPUcycles = 2500  # 2.5 Giga Instructions
            memorySize = 1250  # Upload data size in kB
            deadlineTime = np.random.uniform(60, 300)  # Deadline in seconds

        # Assign other parameters
        priority = np.random.uniform(0, 20)  # Keep priority the same
        delayTolerance = np.random.uniform(0, 1)  # Keep delay tolerance the same
        incentive = np.random.uniform(0.1, 1)  # Keep incentive the same

        # Increment current time by interarrival time
        current_time += datetime.timedelta(seconds=interarrival_time)

        # Set deadline time relative to current time
        deadlineTime = current_time + datetime.timedelta(seconds=deadlineTime)

        # Create the task dictionary
        task_dict = {
            'id': taskI,
            'type': task_type,
            'priority': priority,
            'arrivalTime': current_time,
            'deadlineTime': deadlineTime,
            'delayTolerance': delayTolerance,
            'CPUcycles': CPUcycles,
            'memorySize': memorySize,
            'incentive': incentive
        }

        # Create the task and append it to the tasks list
        task = Task(**task_dict)
        tasks.append(task)

    return tasks

class Network:
    def __init__(self, _clouds, _edges, _volunteers, _localDevice):
        """
        Initialize the network with cloud, edge, volunteer, and local devices.
        """
        self.units = {}
        # Initialize cloud, edge, and volunteer units
        for unitTypeI in [_clouds, _edges, _volunteers, [_localDevice]]:
            for unitI in unitTypeI:
                self.units[unitI.name] = unitI

    def addUnit(self, _unit):
        """
        Add a new unit (cloud, edge, or volunteer) to the network.
        """
        self.units[_unit.name] = _unit

    def setNetworkTypes(self):
        """
        Set network types for each unit: cloud, edge, and volunteers.
        - Cloud: WAN (wide area network)
        - Edge: WLAN (wireless local area network)
        - Volunteers: Wi-Fi, LTE, or 5G based on scenario
        """
        for unitName, unit in self.units.items():
            if unit.getType() == 'cloud':
                unit.setNetworkType('WAN')  # Cloud units use WAN for communication
            elif unit.getType() == 'edge':
                unit.setNetworkType('WLAN')  # Edge units use WLAN for communication with mobile devices
            elif unit.getType() == 'volunteer':
                # Volunteers use Wi-Fi, LTE, or 5G depending on the scenario
                networkType = np.random.choice(['Wi-Fi', 'LTE', '5G'], p=[0.6, 0.3, 0.1])  # Probability-based selection
                unit.setNetworkType(networkType)

    def generateRandomVolunteers(self, _Nvolunteers):
        """
        Generate random volunteer devices with varying capacities and network settings.
        """
        for volunteerI in range(_Nvolunteers):
            name = 'volunteer_' + str(volunteerI)
            self.generateRandomVolunteer(name)

    def generateRandomVolunteer(self, _name):
        """
        Create a random volunteer device with realistic configurations.
        """
        location = np.random.uniform(10, 50)
        CPUspeed = np.random.uniform(1000, 2500)
        bandwidth = np.random.uniform(50, 100)
        latency = np.random.uniform(.001, .01)
        costRate = 'dummyCostRate'
        trust = 1
        availability = 1
        CPUEnergy = np.random.uniform(75, 125)  # Wh
        bandwidthEnergy = np.random.uniform(100, 150)  # Wh per Mbyte

        volunteer_dict = {
            'name': _name,
            'location': location,
            'capacity': {'CPUspeed': CPUspeed},
            'costRate': costRate,
            'connection': {'bandwidth': bandwidth, 'latency': latency},
            'energy': {'CPUEnergy': CPUEnergy, 'bandwidthEnergy': bandwidthEnergy}
        }
        volunteer = Volunteer(trust, availability, **volunteer_dict)
        self.addUnit(volunteer)

    def print(self):
        """
        Print the network structure and details for each unit.
        """
        print("\nNetwork structure:")
        for unitNameI in self.units:
            print(unitNameI)
            if self.units[unitNameI].getType() == "volunteer":
                print("\tAvailability = ", self.units[unitNameI].availability)
                print("\tTrust = ", self.units[unitNameI].trust)

# This function randomly generates a network given the number of clouds and edges
# The resulting network will not have volunteers.
# To randomly generate volunteers, call the
# generateRandomVolunteers(Nvolunteers) member of the network class
def randomNetworkGenerator(_Nclouds, _Nedges):
    clouds = []
    edges = []

    # Generate random cloud servers
    for cloudI in range(_Nclouds):
        name = 'cloud_' + str(cloudI)
        location = np.random.uniform(50, 100)
        CPUspeed = np.random.uniform(3600, 3900)
        bandwidth = np.random.uniform(50, 100)
        latency = np.random.uniform(.01, .08)
        costRate = 'dummyCostRate'

        CPUEnergy = np.random.uniform(100, 150)  # Wh
        bandwidthEnergy = np.random.uniform(175, 225)  # Wh per Mbyte

        cloud_dict = {
            'name': name,
            'location': location,
            'capacity': {'CPUspeed': CPUspeed},
            'costRate': costRate,
            'connection': {'bandwidth': bandwidth, 'latency': latency},
            'energy': {'CPUEnergy': CPUEnergy, 'bandwidthEnergy': bandwidthEnergy}
        }
        cloud = Cloud(**cloud_dict)
        clouds.append(cloud)

    # Generate random edge servers
    for edgeI in range(_Nedges):
        name = 'edge_' + str(edgeI)
        location = np.random.uniform(10, 50)
        CPUspeed = np.random.uniform(2200, 3500)
        bandwidth = np.random.uniform(50, 100)
        latency = np.random.uniform(.001, .01)
        costRate = 'dummyCostRate'
        CPUEnergy = np.random.uniform(75, 150)  # Wh
        bandwidthEnergy = np.random.uniform(150, 200)  # Wh per Mbyte

        edge_dict = {
            'name': name,
            'location': location,
            'capacity': {'CPUspeed': CPUspeed},
            'costRate': costRate,
            'connection': {'bandwidth': bandwidth, 'latency': latency},
            'energy': {'CPUEnergy': CPUEnergy, 'bandwidthEnergy': bandwidthEnergy}
        }
        edge = Edge(**edge_dict)
        edges.append(edge)

    # Generate a local device
    CPUspeed = np.random.uniform(1000, 2000)
    bandwidth = np.random.uniform(10, 50)
    latency = 0
    CPUEnergy = np.random.uniform(75, 125)  # Wh
    bandwidthEnergy = np.random.uniform(75, 125)  # Wh per Mbyte
    local_dict = {
        'capacity': {'CPUspeed': CPUspeed},
        'connection': {'bandwidth': bandwidth, 'latency': latency},
        'energy': {'CPUEnergy': CPUEnergy, 'bandwidthEnergy': bandwidthEnergy}
    }
    local = LocalDevice(**local_dict)

    # Create the network with clouds, edges, and local devices
    network = Network(clouds, edges, [], local)

    # Assign network types to the devices (WAN for cloud, WLAN for edge, Wi-Fi/LTE/5G for volunteers)
    network.setNetworkTypes()

    return network

"""## Simulation environment
We now set up the simulation environment.

### Runtime control class
The runtime control is a smart log that we developed to keep track of the assigned tasks and the related units
"""

class RuntimeControl:
  def __init__(self):
    self.assignedTasks = []
    self.units = []
    self.taskIndex = []
    self.notAssignedTasks = []
    self.deviceAssignments = {
    'cloud': [],
    'edge': [],
    'volunteer': [],
    'localDevice': []
    }

  def appendAssignedTask(self, _task, _device):
    self.assignedTasks.append(_task)
    self.units.append(_device)
    self.taskIndex.append(tuple([_task.id, len(self.assignedTasks)]))

  def appendNotAssignedTask(self, _task):
    self.notAssignedTasks.append(_task)

  def restart(self):
    self.assignedTasks = []
    self.units = []
    self.taskIndex = []
    self.notAssignedTasks = []

  def print(self):
    print("Runtime control:")
    print("\n**************************")
    print("Assigned tasks:\n")
    unitI = 0
    for taskI in self.assignedTasks:
      print("Task ID = ", taskI.id)
      print("Assigned to unit: ", self.units[unitI])
      print("Arrival time = ", taskI.arrivalTime)
      print("StartTime = ", taskI.startTime)
      print("EndTime = ", taskI.endTime)
      print("Assigned %d times" % taskI.assignmentCounter)
      print("\n")
      unitI = unitI + 1

    print("\n**************************")
    print("Not assigned tasks:\n")
    for taskI in self.notAssignedTasks:
      print("Task ID = ", taskI.id)
      print("Assigned %d times" % taskI.assignmentCounter)
      print("\n")

  def getNotAssignedTasks(self):
    return len(self.notAssignedTasks)

"""### Simulation class

The simulation if composed of a network, a  set of tasks and a rule for assigning the tasks to the different units of the network.
"""

def taskSorting(_task):
  return _task.arrivalTime.timestamp()

class Simulation:
    def __init__(self, _network, _tasks, _optimizationGoal):
        self.network = _network
        self.tasks = _tasks
        self.tasks.sort(key=taskSorting)
        self.optimizationGoal = _optimizationGoal
        self.runtimeControl = RuntimeControl()
        self.notAssignedTasks = []

    def getBestDevice(self, _task):
        # Initialize the minimum execution time to a very high number
        executionTimeMin = _task.arrivalTime + datetime.timedelta(days=10000)  # Large time for comparison
        bestDevice = 'None'
        success = False

        # Iterate through the available devices (cloud, edge, and volunteers)
        for unitI in self.network.units:
            unit = self.network.units[unitI]

            # Skip volunteers if they are not available
            if unit.getType() == "volunteer":
                # Check volunteer availability
                if unit.availability == 0:
                    continue
                # Trust check for volunteers
                if self.volunteerTrustCheck(unitI, _task.arrivalTime) == 0:
                    continue

            # Compute execution time for the task on the current unit
            exeT = unit.computeExecutionTime(_task)
            startTime = max(unit.endTime, _task.arrivalTime)

            # Extract the execution time from the returned dictionary
            execution_time = exeT['executionTime']

            # Add the extracted execution time to the start time to calculate end time
            endTime = startTime + execution_time

            # Check if the task can be completed before its deadline
            if endTime <= _task.deadlineTime:
                if endTime < executionTimeMin:
                    executionTimeMin = endTime
                    bestDevice = unitI
                    success = True
                # In case of a tie, pick randomly to avoid bias toward one device type
                elif endTime == executionTimeMin and random.random() > 0.5:
                    bestDevice = unitI
                    success = True

        # If no device can meet the deadline, the task fails
        if not success:
            _task.notAssigned()  # Explicitly mark task as failed if no suitable device found

        return bestDevice, success

    def volunteerTrustCheck(self, _unitName, _currentTime):
        # Check if the volunteer trust is below volunteerTrustTreshold and then if
        # it has been shut down for a time longer than volunteerTimeoutTreshold
        flag = 1
        if self.network.units[_unitName].trust < volunteerTrustTreshold:
            if self.network.units[_unitName].getUntrustedTime(_currentTime) > volunteerTimeoutTreshold:
                self.network.units[_unitName].restoreTrust()
            flag = 0
        return flag

    def shutDownVolunteer(self, _volunteerName, _shutDownTime):
        toReassignTasksIDs = self.network.units[_volunteerName].shutDown(_shutDownTime)
        for taskID in toReassignTasksIDs:
            task = [x for x in self.tasks if x.id == taskID][0]
            task.prepareForReassignment(_shutDownTime)
            bestDevice, success = self.getBestDevice(task)
            if success:
                self.network.units[bestDevice].assignTask(task)
                self.runtimeControl.appendAssignedTask(task, bestDevice)
            else:
                self.runtimeControl.appendNotAssignedTask(task)
                task.notAssigned()

    def run(self):
        self.runtimeControl.restart()

        for taskI in self.tasks:
            bestDevice, success = self.getBestDevice(taskI)

            if success:
                self.network.units[bestDevice].assignTask(taskI)
                if self.network.units[bestDevice].getType() == "volunteer":
                    # Update trust after task assignment, pass network.units to updateTrust
                    self.network.units[bestDevice].updateTrust(taskI, self.network.units)
                self.runtimeControl.appendAssignedTask(taskI, bestDevice)
            else:
                self.runtimeControl.appendNotAssignedTask(taskI)
                taskI.notAssigned()
        return self.runtimeControl

    def runWithShutdown(self):
        self.runtimeControl.restart()

        for taskI in self.tasks:
            if taskI.id == 2:
                self.network.units["volunteer_1"].turnOn()

            bestDevice, success = self.getBestDevice(taskI)

            if success:
                self.network.units[bestDevice].assignTask(taskI)
                if self.network.units[bestDevice].getType() == "volunteer":
                    # Update trust after task assignment, pass network.units to updateTrust
                    self.network.units[bestDevice].updateTrust(taskI, self.network.units)
                self.runtimeControl.appendAssignedTask(taskI, bestDevice)
            else:
                self.runtimeControl.appendNotAssignedTask(taskI)
                taskI.notAssigned()

            if taskI.id == 1:
                shutDownTime = taskI.arrivalTime
                print("\nVolunteer log")
                print(self.network.units["volunteer_1"].printLog())

                print("\nShutDown time = ", shutDownTime)
                self.shutDownVolunteer("volunteer_1", shutDownTime)

                print("\nVolunteer log after shutDown")
                print(self.network.units["volunteer_1"].printLog())
        return self.runtimeControl

    def runWithRandomShutdowns(self, _shutDownFreq, _turnOnFreq):
        self.runtimeControl.restart()

        for taskI in self.tasks:
            if taskI.id % _shutDownFreq == 1:
                shutDownTime = taskI.arrivalTime
                activeVolunteers = self.getActiveVolunteers()
                if len(activeVolunteers) != 0:
                    self.shutDownVolunteer(random.choice(activeVolunteers), shutDownTime)

            bestDevice, success = self.getBestDevice(taskI)
            if success:
                self.network.units[bestDevice].assignTask(taskI)
                if self.network.units[bestDevice].getType() == "volunteer":
                    # Update trust after task assignment, pass network.units to updateTrust
                    self.network.units[bestDevice].updateTrust(taskI, self.network.units)
                self.runtimeControl.appendAssignedTask(taskI, bestDevice)
            else:
                self.runtimeControl.appendNotAssignedTask(taskI)
                taskI.notAssigned()

            if (taskI.id + 3) % _turnOnFreq == 1:
                notActiveVolunteers = self.getNotActiveVolunteers()
                if len(notActiveVolunteers) != 0:
                    self.network.units[random.choice(notActiveVolunteers)].turnOn()
        return self.runtimeControl

    def getActiveVolunteers(self):
        activeVolunteers = []
        for unitI in self.network.units:
            if self.network.units[unitI].getType() == "volunteer":
                if self.network.units[unitI].availability == 1:
                    activeVolunteers.append(self.network.units[unitI].name)
        return activeVolunteers

    def getNotActiveVolunteers(self):
        notActiveVolunteers = []
        for unitI in self.network.units:
            if self.network.units[unitI].getType() == "volunteer":
                if self.network.units[unitI].availability == 0:
                    notActiveVolunteers.append(self.network.units[unitI].name)
        return notActiveVolunteers

    def plotGanttChart(self):
        tasks_list = []
        for taskI in self.tasks:
            if taskI.assignedUnit != "None":
                tasks_list.append(
                    dict(Unit=taskI.assignedUnit, TaskID=taskI.id, Start=taskI.startTime,
                         Finish=taskI.endTime))
        df = pd.DataFrame(tasks_list)
        fig = px.timeline(df, x_start="Start", x_end="Finish", y="Unit",
                          color="TaskID")
        fig.update_yaxes(autorange="reversed")
        fig.show()

    def totalTasksDelay(self):
        tasksDelay = 0
        for taskI in self.tasks:
            if taskI.assignedUnit != "None":
                tasksDelay = tasksDelay + (taskI.endTime - taskI.arrivalTime + \
                                           taskI.wastedTime).total_seconds()
        return tasksDelay

class SimulationNoTrust(Simulation):
    def __init__(self, _network, _tasks, _optimizationGoal):
        # Initialize using the same structure as the original simulation
        super().__init__(_network, _tasks, _optimizationGoal)

    def getBestDevice(self, _task):
        # Initialize the minimum execution time to a very high number
        executionTimeMin = _task.arrivalTime + datetime.timedelta(days=10000)  # Large time for comparison
        bestDevice = 'None'
        success = False

        # Iterate through the available devices (cloud, edge, and volunteers)
        for unitI in self.network.units:
            unit = self.network.units[unitI]

            # Skip volunteers if they are not available (no trust check here)
            if unit.getType() == "volunteer" and unit.availability == 0:
                continue

            # Compute execution time for the task on the current unit
            exeT = unit.computeExecutionTime(_task)
            startTime = max(unit.endTime, _task.arrivalTime)

            # Extract the execution time from the returned dictionary
            execution_time = exeT['executionTime']

            # Add the extracted execution time to the start time to calculate end time
            endTime = startTime + execution_time

            # Check if the task can be completed before its deadline
            if endTime <= _task.deadlineTime:
                if endTime < executionTimeMin:
                    executionTimeMin = endTime
                    bestDevice = unitI
                    success = True
                # In case of a tie, pick randomly to avoid bias toward one device type
                elif endTime == executionTimeMin and random.random() > 0.5:
                    bestDevice = unitI
                    success = True

        # If no device can meet the deadline, the task fails
        if not success:
            _task.notAssigned()  # Explicitly mark task as failed if no suitable device found

        return bestDevice, success



    # In this version, we shut down volunteers without adjusting their trust levels
    def shutDownVolunteer(self, _volunteerName, _shutDownTime):
        # Shut down the volunteer and reassign its tasks
        toReassignTasksIDs = self.network.units[_volunteerName].shutDown(_shutDownTime)
        for taskID in toReassignTasksIDs:
            task = [x for x in self.tasks if x.id == taskID][0]
            task.prepareForReassignment(_shutDownTime)
            bestDevice, success = self.getBestDevice(task)
            if success:
                self.network.units[bestDevice].assignTask(task)
                self.runtimeControl.appendAssignedTask(task, bestDevice)
            else:
                self.runtimeControl.appendNotAssignedTask(task)
                task.notAssigned()

    # We also skip trust-related logic when running the simulation with random shutdowns
    def runWithRandomShutdowns(self, _shutDownFreq, _turnOnFreq):
        self.runtimeControl.restart()

        for taskI in self.tasks:
            # Randomly shut down volunteers
            if taskI.id % _shutDownFreq == 1:
                shutDownTime = taskI.arrivalTime
                activeVolunteers = self.getActiveVolunteers()
                if len(activeVolunteers) != 0:
                    self.shutDownVolunteer(random.choice(activeVolunteers), shutDownTime)

            # Assign the best available device
            bestDevice, success = self.getBestDevice(taskI)
            if success:
                self.network.units[bestDevice].assignTask(taskI)
                self.runtimeControl.appendAssignedTask(taskI, bestDevice)
            else:
                self.runtimeControl.appendNotAssignedTask(taskI)
                taskI.notAssigned()

            # Randomly turn on volunteers
            if (taskI.id + 3) % _turnOnFreq == 1:
                notActiveVolunteers = self.getNotActiveVolunteers()
                if len(notActiveVolunteers) != 0:
                    self.network.units[random.choice(notActiveVolunteers)].turnOn()

        return self.runtimeControl

    # Override to remove the trust logic
    def volunteerTrustCheck(self, _unitName, _currentTime):
        # No need to check trust in this class, so always return "trusted"
        return 1

def calculateDataTransferTime(task, connection):
    # Calculate the data transfer time
    dataTransferTime = task.memorySize / connection['bandwidth'] + connection['latency']
    return dataTransferTime  # This will be in seconds, assuming bandwidth is in Mbit/s and latency in seconds

import numpy as np
import datetime
import matplotlib.pyplot as plt

# Define a function to count task distribution across devices and track energy consumption
def task_distribution_summary(runtimeControl, network):
    # Create a dictionary to track the number of tasks and energy consumption assigned to each device type
    distribution = {
        "cloud": {"tasks": 0, "energy": 0},
        "edge": {"tasks": 0, "energy": 0},
        "volunteer": {"tasks": 0, "energy": 0},
        "localDevice": {"tasks": 0, "energy": 0}
    }

    # Loop through each assigned task and count the assignments, also sum energy consumption
    for taskI in runtimeControl.assignedTasks:
        assigned_unit = taskI.assignedUnit
        unit_type = network.units[assigned_unit].getType()
        if unit_type in distribution:
            distribution[unit_type]["tasks"] += 1
            distribution[unit_type]["energy"] += network.units[assigned_unit].totalEnergyConsumed

    # Print the summary of task assignments and energy consumption
    print("Task Distribution Summary:")
    print(f"Cloud: {distribution['cloud']['tasks']} tasks, Energy: {distribution['cloud']['energy']} Wh")
    print(f"Edge: {distribution['edge']['tasks']} tasks, Energy: {distribution['edge']['energy']} Wh")
    print(f"Volunteer: {distribution['volunteer']['tasks']} tasks, Energy: {distribution['volunteer']['energy']} Wh")
    print(f"Local Device: {distribution['localDevice']['tasks']} tasks, Energy: {distribution['localDevice']['energy']} Wh")

    return distribution

# Define the main function that runs the simulation and analyzes task distribution and energy
def run_task_distribution_test(num_clouds, num_edges, num_volunteers, num_tasks):
    """
    Run the simulation to test task distribution across cloud, edge, volunteers, and local device.
    """
    # Generate the network with clouds, edges, and volunteers
    network = randomNetworkGenerator(num_clouds, num_edges)
    network.generateRandomVolunteers(num_volunteers)

    # Generate random tasks
    tasks = randomTaskGenerator(num_tasks, simulationLength)

    # Create the simulation object
    simulation = Simulation(network, tasks, "minimizeLatency")

    # Run the simulation (you can choose a specific shutdown or no-shutdown mode)
    runtimeControl = simulation.run()
    simulation.plotGanttChart()  # You can replace with other modes like runWithRandomShutdowns

    # Analyze the task distribution and energy consumption
    distribution = task_distribution_summary(runtimeControl, network)

    return distribution

# Parameters for the test
num_clouds = 1        # Number of cloud units
num_edges = 3         # Number of edge units
num_volunteers = 0    # Number of volunteer units
num_tasks = 2000      # Total number of tasks

# Run the test
task_distribution = run_task_distribution_test(num_clouds, num_edges, num_volunteers, num_tasks)

# Extract energy data for plotting
cloud_energy = task_distribution['cloud']['energy']
edge_energy = task_distribution['edge']['energy']
volunteer_energy = task_distribution['volunteer']['energy']
local_device_energy = task_distribution['localDevice']['energy']

# Plot energy consumption across device types
device_types = ['Cloud', 'Edge', 'Volunteers', 'Local Device']
energy_values = [cloud_energy, edge_energy, volunteer_energy, local_device_energy]

plt.figure(figsize=(10, 6))
plt.bar(device_types, energy_values, color=['blue', 'green', 'orange', 'red'])
plt.title('Energy Consumption by Device Type')
plt.xlabel('Device Type')
plt.ylabel('Total Energy Consumption (Wh)')
plt.grid(True)
plt.show()

import numpy as np
import datetime
import matplotlib.pyplot as plt

# Define a function to count task distribution across devices and track energy consumption
def task_distribution_summary(runtimeControl, network, total_tasks):
    # Create a dictionary to track the number of tasks and energy consumption assigned to each device type
    distribution = {
        "cloud": {"tasks": 0, "energy": 0},
        "edge": {"tasks": 0, "energy": 0},
        "volunteer": {"tasks": 0, "energy": 0},
        "localDevice": {"tasks": 0, "energy": 0},
        "unassigned": 0  # Track unassigned tasks
    }

    # Loop through each assigned task and count the assignments, also sum energy consumption
    for taskI in runtimeControl.assignedTasks:
        assigned_unit = taskI.assignedUnit
        if assigned_unit is not None:
            unit_type = network.units[assigned_unit].getType()
            if unit_type in distribution:
                distribution[unit_type]["tasks"] += 1
                distribution[unit_type]["energy"] += network.units[assigned_unit].totalEnergyConsumed
        else:
            distribution["unassigned"] += 1  # Count unassigned tasks

    # Calculate the missing tasks
    total_assigned_tasks = sum(distribution[unit]["tasks"] for unit in distribution if unit != "unassigned")
    unassigned_tasks = total_tasks - total_assigned_tasks

    # Print the summary of task assignments, unassigned tasks, and energy consumption
    print("Task Distribution Summary:")
    print(f"Cloud: {distribution['cloud']['tasks']} tasks, Energy: {distribution['cloud']['energy']} Wh")
    print(f"Edge: {distribution['edge']['tasks']} tasks, Energy: {distribution['edge']['energy']} Wh")
    print(f"Volunteer: {distribution['volunteer']['tasks']} tasks, Energy: {distribution['volunteer']['energy']} Wh")
    print(f"Local Device: {distribution['localDevice']['tasks']} tasks, Energy: {distribution['localDevice']['energy']} Wh")
    print(f"Unassigned tasks: {unassigned_tasks}")

    return distribution

# Define the main function that runs the simulation and analyzes task distribution and energy
def run_task_distribution_test(num_clouds, num_edges, num_volunteers, num_tasks):
    """
    Run the simulation to test task distribution across cloud, edge, volunteers, and local device.
    """
    # Generate the network with clouds, edges, and volunteers
    network = randomNetworkGenerator(num_clouds, num_edges)
    network.generateRandomVolunteers(num_volunteers)

    # Generate random tasks
    tasks = randomTaskGenerator(num_tasks, simulationLength)

    # Create the simulation object
    simulation = Simulation(network, tasks, "minimizeLatency")

    # Run the simulation (you can choose a specific shutdown or no-shutdown mode)
    runtimeControl = simulation.run()
    simulation.plotGanttChart()  # You can replace with other modes like runWithRandomShutdowns

    # Analyze the task distribution and energy consumption
    distribution = task_distribution_summary(runtimeControl, network, num_tasks)

    return distribution

# Parameters for the test
num_clouds = 1        # Number of cloud units
num_edges = 3         # Number of edge units
num_volunteers = 0    # Number of volunteer units
num_tasks = 2000      # Total number of tasks

# Run the test
task_distribution = run_task_distribution_test(num_clouds, num_edges, num_volunteers, num_tasks)

# Extract energy data for plotting
cloud_energy = task_distribution['cloud']['energy']
edge_energy = task_distribution['edge']['energy']
volunteer_energy = task_distribution['volunteer']['energy']
local_device_energy = task_distribution['localDevice']['energy']

# Plot energy consumption across device types
device_types = ['Cloud', 'Edge', 'Volunteers', 'Local Device']
energy_values = [cloud_energy, edge_energy, volunteer_energy, local_device_energy]

plt.figure(figsize=(10, 6))
plt.bar(device_types, energy_values, color=['blue', 'green', 'orange', 'red'])
plt.title('Energy Consumption by Device Type')
plt.xlabel('Device Type')
plt.ylabel('Total Energy Consumption (Wh)')
plt.grid(True)
plt.show()

"""### **Testing**

## **Additional testing **
"""



"""**distribution test**"""